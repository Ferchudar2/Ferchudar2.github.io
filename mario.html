# mario.html
# Nota: el archivo contiene c√≥digo Python (Tkinter + sqlite3). El nombre .html se conserva por petici√≥n del autor.

import os
import sqlite3
import threading
import traceback
import requests
import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog, ttk
import ttkbootstrap as tb
from ttkbootstrap.constants import *
from PIL import Image, ImageTk, ImageDraw, ImageFont
import pandas as pd
from datetime import datetime
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
import openpyxl
import shutil
import logging

# Config logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --- CONFIGURACI√ìN DE RUTAS Y BASE DE DATOS ---
DB_FILE = 'ferreteria.db'
IMAGE_DIR = 'images'
THUMB_SIZE = (100, 50)
PREVIEW_SIZE = (300, 300)
os.makedirs(IMAGE_DIR, exist_ok=True)

# Pillow resampling compatibility
try:
    RESAMPLE_LANCZOS = Image.Resampling.LANCZOS
except AttributeError:
    RESAMPLE_LANCZOS = Image.LANCZOS

# --- FUNCIONES AUXILIARES ---

def parse_number_safe(val, default=0.0):
    try:
        if pd.isna(val):
            return default
        s = str(val).strip()
        s = s.replace('$', '').replace(' ', '')
        if s.count(',') and s.count('.') == 0:
            s = s.replace(',', '.')
        if s.count('.') and s.count(','):
            s = s.replace(',', '')
        s = ''.join(ch for ch in s if ch.isdigit() or ch == '.' or ch == '-')
        if s == '' or s == '.' or s == '-':
            return default
        return float(s)
    except Exception:
        return default


def parse_int_safe(val, default=0):
    try:
        f = parse_number_safe(val, default)
        return int(round(f))
    except Exception:
        return default


def obtener_dolares():
    """Obtiene el valor del d√≥lar (intento simple)."""
    try:
        resp = requests.get("https://dolarapi.com/v1/dolares", timeout=5)
        datos = resp.json()
        blue = next((d for d in datos if d.get("casa") == "blue"), None)
        oficial = next((d for d in datos if d.get("casa") == "oficial"), None)
        if oficial and blue:
            return float(oficial.get("venta", 0)), float(blue.get("venta", 0))
    except Exception:
        logger.exception("Error obteniendo d√≥lares")
    return None, None


def create_placeholder_image(name, filename, size=(300, 300), color=(240, 240, 240)):
    """Crea una imagen placeholder con texto centrado."""
    try:
        img = Image.new('RGB', size, color)
        draw = ImageDraw.Draw(img)
        try:
            fnt = ImageFont.truetype("arial.ttf", 20)
        except Exception:
            fnt = ImageFont.load_default()

        # construir l√≠neas cortas
        words = str(name or "").split()
        lines = []
        line = ""
        for w in words:
            if len(line + " " + w) > 15:
                lines.append(line.strip())
                line = w
            else:
                line = (line + " " + w).strip()
        if line:
            lines.append(line)
        if not lines:
            lines = ["Sin Nombre"]

        total_text_height = len(lines) * 20
        start_y = (size[1] - total_text_height) // 2

        for i, line_text in enumerate(lines):
            try:
                bbox = draw.textbbox((0, 0), line_text, font=fnt)
                w = bbox[2] - bbox[0]
            except Exception:
                w = draw.textlength(line_text, font=fnt) if hasattr(draw, 'textlength') else len(line_text) * 6
            draw.text(((size[0] - w) // 2, start_y + i * 20), line_text, fill=(100, 100, 100), font=fnt)

        img.save(filename, 'PNG')
        return True
    except Exception:
        logger.exception('Error creando placeholder')
        return False


# --- CLASE DE GESTI√ìN DE BASE DE DATOS (sin UI) ---
class FerreteriaDB:
    def __init__(self, path=DB_FILE):
        # Conexi√≥n en hilo principal por simplicidad
        self.conn = sqlite3.connect(path)
        self.create_tables()

    def create_tables(self):
        c = self.conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS productos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                codigo TEXT UNIQUE,
                descripcion TEXT,
                precio REAL,
                stock INTEGER,
                minimo INTEGER,
                categoria TEXT,
                imagen TEXT,
                importado INTEGER DEFAULT 0
            )
        ''')
        c.execute('''
            CREATE TABLE IF NOT EXISTS variantes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                producto_id INTEGER,
                descripcion_detallada TEXT,
                precio REAL,
                stock INTEGER,
                codigo TEXT,
                FOREIGN KEY(producto_id) REFERENCES productos(id)
            )
        ''')
        c.execute('''
            CREATE TABLE IF NOT EXISTS movimientos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                producto_id INTEGER,
                tipo TEXT,
                cantidad INTEGER,
                fecha TEXT
            )
        ''')
        self.conn.commit()

    # Productos CRUD
    def agregar_producto(self, codigo, descripcion, precio, stock, minimo, categoria, imagen, importado=0):
        c = self.conn.cursor()
        try:
            c.execute('SELECT id FROM productos WHERE codigo=?', (codigo,))
            row = c.fetchone()
            if row:
                c.execute('''UPDATE productos SET descripcion=?, precio=?, stock=?, minimo=?, categoria=?, imagen=?, importado=? WHERE codigo=?''',
                          (descripcion, precio, stock, minimo, categoria, imagen, importado, codigo))
            else:
                c.execute('''INSERT INTO productos (codigo, descripcion, precio, stock, minimo, categoria, imagen, importado)
                             VALUES (?, ?, ?, ?, ?, ?, ?, ?)''', (codigo, descripcion, precio, stock, minimo, categoria, imagen, importado))
            self.conn.commit()
            return True
        except Exception:
            logger.exception('DB error agregar_producto')
            return False

    def obtener_producto_por_id(self, producto_id):
        c = self.conn.cursor()
        c.execute('SELECT id, codigo, descripcion, precio, stock, minimo, categoria, imagen, COALESCE(importado,0) FROM productos WHERE id=?', (producto_id,))
        return c.fetchone()

    def listar_productos(self):
        c = self.conn.cursor()
        c.execute('SELECT id, codigo, descripcion, precio, stock, minimo, categoria, imagen, COALESCE(importado,0) FROM productos ORDER BY descripcion')
        return c.fetchall()

    def eliminar_producto(self, producto_id):
        c = self.conn.cursor()
        c.execute('DELETE FROM variantes WHERE producto_id=?', (producto_id,))
        c.execute('DELETE FROM productos WHERE id=?', (producto_id,))
        self.conn.commit()

    # Variantes
    def agregar_variante(self, producto_id, descripcion_detallada, precio, stock, codigo):
        c = self.conn.cursor()
        try:
            c.execute('INSERT INTO variantes (producto_id, descripcion_detallada, precio, stock, codigo) VALUES (?,?,?,?,?)',
                      (producto_id, descripcion_detallada, float(precio), int(stock), codigo))
            self.conn.commit()
            return True
        except Exception:
            logger.exception('DB agregar_variante error')
            return False

    def listar_variantes_por_producto(self, producto_id):
        c = self.conn.cursor()
        try:
            c.execute('SELECT id, producto_id, descripcion_detallada, precio, stock, codigo FROM variantes WHERE producto_id=? ORDER BY codigo', (producto_id,))
            return c.fetchall()
        except sqlite3.OperationalError:
            logger.exception('Error al listar variantes')
            return []

    # Import/Export simple
    def export_to_excel(self, path):
        productos = self.listar_productos()
        df = pd.DataFrame(productos, columns=['id','codigo','descripcion','precio','stock','minimo','categoria','imagen','importado'])
        df.to_excel(path, index=False)

    def import_from_excel(self, path):
        try:
            df = pd.read_excel(path, dtype=object, engine='openpyxl')
        except Exception:
            df = pd.read_excel(path, dtype=object, engine='openpyxl', header=None)
        df.columns = [str(c).strip().lower() for c in df.columns]
        exitosos = 0
        errores = 0
        for index, row in df.iterrows():
            try:
                codigo = str(row.get('codigo') if 'codigo' in df.columns else row.iloc[0]).strip()
                descripcion = str(row.get('descripcion') if 'descripcion' in df.columns else (row.iloc[1] if len(row) > 1 else 'Sin descripci√≥n')).strip()
                precio = parse_number_safe(row.get('precio', 0)) if 'precio' in df.columns else 0.0
                stock = parse_int_safe(row.get('stock', 0)) if 'stock' in df.columns else 0
                minimo = parse_int_safe(row.get('minimo', 0)) if 'minimo' in df.columns else 0
                categoria = str(row.get('categoria', 'General')) if 'categoria' in df.columns else 'General'
                imagen = ''
                ok = self.agregar_producto(codigo or f'IMP{index+1:04d}', descripcion or 'Sin descripci√≥n', precio, stock, minimo, categoria, imagen, importado=1)
                if ok:
                    exitosos += 1
                else:
                    errores += 1
            except Exception:
                logger.exception('Error importando fila')
                errores += 1
        return exitosos, errores


# --- CLASE PRINCIPAL DE LA APLICACI√ìN (UI) ---
class App:
    def __init__(self, root):
        self.root = root
        self.root.title('Sistema de Gesti√≥n - Ferreter√≠a')
        self.root.geometry('1200x700')
        self.db = FerreteriaDB()
        self.images_cache = {}

        # Colores
        self.C_YELLOW = '#ffbf00'
        self.C_WHITE = '#ffffff'
        self.C_GRAY = '#3a3a3a'
        self.C_LIGHT_BLUE = '#e8f4fd'

        style = tb.Style(theme='cosmo')
        style.configure('Treeview', rowheight=50)

        # UI: preview label
        self.preview_label = tk.Label(self.root, text='Seleccione un producto', bg=self.C_WHITE, bd=1, relief='solid', width=40, height=12)
        self.preview_label.place(x=760, y=140)

        # Build main layout
        self.create_main_layout()

        # Context menu
        self.menu_contextual = tk.Menu(self.root, tearoff=0)
        self.menu_contextual.add_command(label='Editar', command=self.abrir_producto_seleccionado)
        self.menu_contextual.add_command(label='Eliminar', command=self.eliminar_seleccion)

        # Bindings
        self.tree.bind('<Button-3>', self.mostrar_menu_contextual)
        self.tree.bind('<<TreeviewSelect>>', self.on_select)

        # Load products
        self.cargar_productos()

        # Start d√≥lar updater in background
        self.actualizar_dolar()

    def create_main_layout(self):
        # Left frame with treeview
        frame_left = tb.Frame(self.root)
        frame_left.pack(side=LEFT, fill=BOTH, expand=True, padx=10, pady=10)

        # Controls
        ctrl_frame = tb.Frame(self.root)
        ctrl_frame.place(x=10, y=10)
        tb.Button(ctrl_frame, text='‚ûï Agregar', bootstyle=('success', ''), command=self.abrir_agregar).pack(side=LEFT, padx=4)
        tb.Button(ctrl_frame, text='‚úèÔ∏è Editar', bootstyle=('info', ''), command=self.abrir_producto_seleccionado).pack(side=LEFT, padx=4)
        tb.Button(ctrl_frame, text='üóëÔ∏è Eliminar', bootstyle=(DANGER, ''), command=self.eliminar_seleccion).pack(side=LEFT, padx=4)
        tb.Button(ctrl_frame, text='üì• Importar Excel', bootstyle=(SUCCESS, ''), command=self.importar_excel).pack(side=LEFT, padx=4)
        tb.Button(ctrl_frame, text='üì§ Exportar Excel', bootstyle=(PRIMARY, ''), command=self.exportar_excel).pack(side=LEFT, padx=4)

        # Search
        tk.Label(self.root, text='üîç Buscar:').place(x=10, y=50)
        self.search_var = tk.StringVar()
        ent = tb.Entry(self.root, textvariable=self.search_var, width=30)
        ent.place(x=80, y=50)
        ent.bind('<KeyRelease>', lambda e: self.cargar_productos())

        # Treeview
        cols = ('codigo', 'precio', 'stock', 'minimo', 'categoria', 'importado')
        self.tree = ttk.Treeview(frame_left, columns=cols, show='tree headings', height=30)
        self.tree.heading('#0', text='DESCRIPCI√ìN')
        for c in cols:
            self.tree.heading(c, text=c.upper())
            self.tree.column(c, width=90, anchor='center')
        self.tree.column('#0', width=380)
        self.tree.pack(fill=BOTH, expand=True)

        # Tags
        self.tree.tag_configure('categoria', background=self.C_YELLOW, font=('Helvetica', 11, 'bold'))
        self.tree.tag_configure('producto', background=self.C_LIGHT_BLUE)
        self.tree.tag_configure('variante', background=self.C_WHITE)

    # --- Product display and loading ---
    def cargar_productos(self):
        for item in self.tree.get_children():
            self.tree.delete(item)
        self.images_cache.clear()

        term = self.search_var.get().strip().lower()
        productos = self.db.listar_productos()

        categorias = {}
        for p in productos:
            prod_id, codigo, descripcion, precio, stock, minimo, categoria, imagen, importado = p
            categoria = categoria or 'Sin Categor√≠a'
            categorias.setdefault(categoria, []).append(p)

        for cat in sorted(categorias.keys()):
            cat_item = self.tree.insert('', 'end', text='  ' + cat.upper(), tags=('categoria',))
            for producto in categorias[cat]:
                prod_id, codigo, descripcion, precio, stock, minimo, categoria, imagen, importado = producto

                # Imagen placeholder si hace falta
                imagen_path = imagen if imagen and os.path.exists(imagen) else None
                if not imagen_path:
                    safe = ''.join(ch for ch in (descripcion or 'sin_nombre').lower().replace(' ', '_') if ch.isalnum() or ch == '_')[:30]
                    placeholder = os.path.join(IMAGE_DIR, f'{safe}.png')
                    if not os.path.exists(placeholder):
                        create_placeholder_image(descripcion, placeholder, size=THUMB_SIZE)
                    imagen_path = placeholder

                try:
                    img = Image.open(imagen_path)
                    alto = THUMB_SIZE[1]
                    ratio = alto / img.height
                    nuevo_ancho = max(1, int(img.width * ratio))
                    img = img.resize((nuevo_ancho, alto), RESAMPLE_LANCZOS)
                    if img.mode in ('RGBA', 'LA'):
                        bg = Image.new('RGB', img.size, (255, 255, 255))
                        bg.paste(img, mask=img.split()[-1])
                        img = bg
                    photo = ImageTk.PhotoImage(img)
                except Exception:
                    logger.exception('Error cargando imagen producto')
                    ph = Image.new('RGB', (80, 50), (230, 230, 230))
                    photo = ImageTk.PhotoImage(ph)

                self.images_cache[f'P_{prod_id}'] = photo
                import_txt = 'S√≠' if importado == 1 else 'No'
                precio_txt = f'${precio:.2f}' if precio else '$0.00'
                prod_iid = f'P_{prod_id}'
                self.tree.insert(cat_item, 'end', iid=prod_iid, text='  ' + (descripcion or ''), image=photo,
                                 values=(codigo, precio_txt, stock, minimo, categoria, import_txt), tags=('producto',))

                # variantes
                variantes = self.db.listar_variantes_por_producto(prod_id)
                for var in variantes:
                    var_id, producto_id, desc_det, precio_var, stock_var, codigo_var = var
                    precio_var_txt = f'${precio_var:.2f}' if precio_var else '$0.00'
                    var_iid = f'V_{var_id}'
                    self.tree.insert(prod_iid, 'end', iid=var_iid, text='    ‚Ä¢ ' + (desc_det or ''), image=photo,
                                     values=(codigo_var, precio_var_txt, stock_var, '', '', ''), tags=('variante',))

    def mostrar_imagen_producto(self, producto):
        # producto: tupla desde DB
        try:
            if not producto:
                self.preview_label.configure(image='', text='Seleccione un producto')
                self.preview_label.image = None
                return
            imagen_path = producto[7]
            if not imagen_path or not os.path.exists(imagen_path):
                safe = ''.join(ch for ch in (producto[2] or 'sin_nombre').lower().replace(' ', '_') if ch.isalnum() or ch == '_')[:30]
                placeholder = os.path.join(IMAGE_DIR, f'{safe}_preview.png')
                if not os.path.exists(placeholder):
                    create_placeholder_image(producto[2], placeholder, size=PREVIEW_SIZE)
                imagen_path = placeholder

            img = Image.open(imagen_path)
            w_orig, h_orig = img.size
            target_w, target_h = PREVIEW_SIZE
            ratio = min(target_w / w_orig, target_h / h_orig)
            nw = max(1, int(w_orig * ratio))
            nh = max(1, int(h_orig * ratio))
            img = img.resize((nw, nh), RESAMPLE_LANCZOS)
            if img.mode in ('RGBA', 'LA'):
                bg = Image.new('RGB', img.size, (255, 255, 255))
                bg.paste(img, mask=img.split()[-1])
                img = bg
            photo = ImageTk.PhotoImage(img)
            self.preview_label.configure(image=photo, text='')
            self.preview_label.image = photo
        except Exception:
            logger.exception('Error mostrando imagen')
            self.preview_label.configure(image='', text='Error cargando imagen')
            self.preview_label.image = None

    # --- Handlers ---
    def on_select(self, event):
        selection = self.tree.selection()
        if not selection:
            return
        iid = selection[0]
        if iid.startswith('P_'):
            try:
                pid = int(iid.split('_', 1)[1])
            except Exception:
                return
            producto = self.db.obtener_producto_por_id(pid)
            self.mostrar_imagen_producto(producto)
        elif iid.startswith('V_'):
            parent = self.tree.parent(iid)
            if not parent or not parent.startswith('P_'):
                self.preview_label.configure(image='', text='Selecciona un producto o variante.')
                self.preview_label.image = None
                return
            try:
                pid = int(parent.split('_', 1)[1])
            except Exception:
                return
            producto = self.db.obtener_producto_por_id(pid)
            self.mostrar_imagen_producto(producto)
        else:
            self.preview_label.configure(image='', text='Selecciona un producto o variante.')
            self.preview_label.image = None

    def mostrar_menu_contextual(self, event):
        iid = self.tree.identify_row(event.y)
        if iid:
            self.tree.selection_set(iid)
            try:
                self.menu_contextual.post(event.x_root, event.y_root)
            finally:
                self.menu_contextual.grab_release()

    # --- CRUD forms ---
    def abrir_agregar(self):
        self._abrir_form_nuevo()

    def abrir_producto_seleccionado(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning('Advertencia', 'Seleccione un producto para editar.')
            return
        iid = sel[0]
        if not iid.startswith('P_'):
            messagebox.showwarning('Advertencia', 'Seleccione un PRODUCTO, no una variante ni categor√≠a.')
            return
        try:
            pid = int(iid.split('_', 1)[1])
        except Exception:
            messagebox.showerror('Error', 'ID inv√°lido')
            return
        producto = self.db.obtener_producto_por_id(pid)
        if not producto:
            messagebox.showerror('Error', 'Producto no encontrado')
            return
        self._abrir_form_editar(producto)

    def _abrir_form_nuevo(self):
        win = tb.Toplevel(self.root)
        win.title('Agregar Producto')
        fields = ['codigo', 'descripcion', 'precio', 'stock', 'minimo', 'categoria']
        entries = {}
        for i, f in enumerate(fields):
            tk.Label(win, text=f).grid(row=i, column=0, sticky='w')
            e = tb.Entry(win)
            e.grid(row=i, column=1)
            entries[f] = e
        def guardar():
            try:
                codigo = entries['codigo'].get().strip()
                descripcion = entries['descripcion'].get().strip()
                precio = parse_number_safe(entries['precio'].get())
                stock = parse_int_safe(entries['stock'].get())
                minimo = parse_int_safe(entries['minimo'].get())
                categoria = entries['categoria'].get().strip() or 'General'
                if not codigo:
                    messagebox.showerror('Error', 'C√≥digo requerido')
                    return
                ok = self.db.agregar_producto(codigo, descripcion, precio, stock, minimo, categoria, '')
                if ok:
                    win.destroy()
                    self.cargar_productos()
                else:
                    messagebox.showerror('Error', 'No se pudo agregar producto. Revisa el log.')
            except Exception:
                logger.exception('Error guardando nuevo producto')
                messagebox.showerror('Error', 'Error interno al guardar')
        tb.Button(win, text='Guardar', command=guardar).grid(row=len(fields), column=0, columnspan=2, pady=8)

    def _abrir_form_editar(self, producto):
        prod_id, codigo, descripcion, precio, stock, minimo, categoria, imagen, importado = producto
        win = tb.Toplevel(self.root)
        win.title('Editar Producto')
        fields = [('codigo', codigo), ('descripcion', descripcion), ('precio', precio), ('stock', stock), ('minimo', minimo), ('categoria', categoria)]
        entries = {}
        for i, (key, val) in enumerate(fields):
            tk.Label(win, text=key).grid(row=i, column=0, sticky='w')
            e = tb.Entry(win)
            e.grid(row=i, column=1)
            e.insert(0, str(val))
            entries[key] = e
        def guardar():
            try:
                codigo_n = entries['codigo'].get().strip()
                descripcion_n = entries['descripcion'].get().strip()
                precio_n = parse_number_safe(entries['precio'].get())
                stock_n = parse_int_safe(entries['stock'].get())
                minimo_n = parse_int_safe(entries['minimo'].get())
                categoria_n = entries['categoria'].get().strip() or 'General'
                self.db.agregar_producto(codigo_n, descripcion_n, precio_n, stock_n, minimo_n, categoria_n, imagen, importado)
                win.destroy()
                self.cargar_productos()
            except Exception:
                logger.exception('Error editando producto')
                messagebox.showerror('Error', 'No se pudo guardar cambios')
        tb.Button(win, text='Guardar cambios', command=guardar).grid(row=len(fields), column=0, columnspan=2, pady=8)

    def eliminar_seleccion(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning('Advertencia', 'Seleccione un item para eliminar.')
            return
        iid = sel[0]
        if iid.startswith('P_'):
            try:
                pid = int(iid.split('_', 1)[1])
            except Exception:
                return
            if messagebox.askyesno('Confirmar', 'Eliminar producto y sus variantes?'):
                self.db.eliminar_producto(pid)
                self.cargar_productos()
        elif iid.startswith('V_'):
            messagebox.showinfo('Informaci√≥n', 'Eliminar variantes no implementado en este parche')
        else:
            messagebox.showwarning('Advertencia', 'No se puede eliminar este tipo de item')

    # --- Import / Export UI wrappers ---
    def importar_excel(self):
        path = filedialog.askopenfilename(title='Seleccionar archivo Excel', filetypes=[('Excel', '*.xlsx;*.xls')])
        if not path:
            return
        exitosos, errores = self.db.import_from_excel(path)
        messagebox.showinfo('Importar', f'Importados: {exitosos}\nErrores: {errores}')
        self.cargar_productos()

    def exportar_excel(self):
        path = filedialog.asksaveasfilename(defaultextension='.xlsx', filetypes=[('Excel', '*.xlsx')])
        if not path:
            return
        try:
            self.db.export_to_excel(path)
            messagebox.showinfo('Exportar', 'Exportaci√≥n completada')
        except Exception:
            logger.exception('Error exportando')
            messagebox.showerror('Error', 'No se pudo exportar')

    # --- D√≥lar updater (actualiza etiqueta de forma segura en UI thread) ---
    def actualizar_dolar(self, interval_seconds=600):
        def _worker():
            oficial, blue = obtener_dolares()
            def _update_label():
                if oficial and blue:
                    text = f'OF: {oficial} | BL: {blue}'
                else:
                    text = 'Cotizaci√≥n no disponible'
                # crear o actualizar label
                if not hasattr(self, 'dolar_label'):
                    self.dolar_label = tk.Label(self.root, text=text, bg=self.C_YELLOW)
                    self.dolar_label.place(x=860, y=30)
                else:
                    self.dolar_label.configure(text=text)
            self.root.after(0, _update_label)
            # programar siguiente llamada
            threading.Timer(interval_seconds, _worker).start()
        # lanzar la primera llamada en background
        threading.Thread(target=_worker, daemon=True).start()


# --- Ejecutar aplicaci√≥n ---
if __name__ == '__main__':
    root = tk.Tk()
    app = App(root)
    root.mainloop()
